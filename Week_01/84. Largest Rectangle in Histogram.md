84. Largest Rectangle in Histogram
- 暴力解法:  
  和5. Longest Palindromix Substring的中心拓展解法很相似。都是用一个for枚举每一个元素，然后在for里面每枚举一个元素就从以此元素为中心，枚举两边的元素来找到满足条件的答案。本题需要找到的是当前元素左边和右边第一个高度比它小的元素。因为最坏情况下n个元素都需要找遍左右两边的n-1个元素，所以需要O(n^2)的时间复杂度。  

- 怎么把for循环里面向左右搜索第一个比当前元素小的这段O(n)的逻辑优化到O(1)?典型的做法是记录遍历过的元素中蕴含的一些信息。像2Sum用的是哈希表记录目标元素和遍历过的元素之间的差，然后利用hash表O(1)的查询时间优化。  

    可以先从最简单的情况想起，那就是当前元素左边第一个元素正好是它左边第一个比它小的元素，右边第一个元素正好是右边第一个比它小的元素，如[1,3,2]中的3。这时候3找到左右边界的时间不就是O(1)了吗？

    然而如果是[1,3,4,2]中的3呢？这里的3要找到右边界，复杂度就超过了O(1)，因为被4“挡住”。这里就是拼智商的时候了：复杂度超过O(1)的时候，我不找了总可以吧？要等到将来O(1)的时机来临的时候再找。什么时候才是O(1)找到右边界的时机呢？正是[1,3,2]那个例子里一样，3右边第一个数就比3小，没有比3大的数“挡住”。

    而对于[1,3,4,2]中的4而言，其处境和[1,3,2]中的3一模一样，都是能以O(1)的时间复杂度找到左右边界。此时4设身处地为3想了想：我太高了，挡住了3，要是我不存在的话，3就能像我一样愉快地O(1)了。所以可以得出一个操作：能确定左右边界的4计算完了以后要把自己移除，为上一个元素(3)创造O(1)的机会。
    
    用完就丢(出栈)，从这点可以联想到栈。那么什么时候入栈？上面的例子中看到后面的元素“挡住”自己的时候，先不计算，这种操作就是入栈。而且这样入栈会形成一个单调递增的栈。

    注意这里的栈要储存的是元素的下标，因为要用下标来计算宽度。

    和哈希表查询任意键值的时间为O(1)不同，这里的单调递增栈只能保证查询左边第一个比自身小的元素的时间复杂度是O(1)。